<html>
  <head>
    <script src="js/snap.svg.js"></script>
  </head>
  <body>
    <div id="content">
      <!-- The stroke dash-array and stroke-dashoffset, and animate.from must be the same as the length of the line (here, it's 500).
	    I think I'll have to set the animate.dur depending on the length of the line
            being drawn: shorter for short lines and longer for long lines. -->
      <!-- Use http://snapsvg.io/start/ Less object-orienty, but backed by adobe -->
      <!-- Or http://svgjs.com/  This one seems more object-oriented, but not as much traction.           svg.js's polyline plot() seems to have nice animation features. -->
      <!-- 
      <svg id="svgout" width="500" height="500">
        <line x1="0" y1="0" x2="300" y2="400"
	  style="stroke:rgb(255,0,0);stroke-width:2;stroke-dasharray:500,500; stroke-dashoffset:500">
          <animate begin="0" attributeName="stroke-dashoffset"
              from="500" to="0" dur="2s" fill="freeze"/>
        </line>
</svg>
       -->
      <!-- <svg id="svgout" width="500" height="500"></svg> -->

    </div>
    <script>


/*
var svgString1 = '<path id="s3" d="M 60 0 L 120 0 L 180 60 L 180 120 L 120 180 L 60 180 L 0 120 L 0 60 Z" stroke="blue"/>';
var svgString2 = '<path id="s3" d="M 60 0 L 120 0 L 180 60 L 180 120 L 120 180 L 60 180 L 0 120 L 0 60 Z" stroke="red"/>';
*/

function Canvas(options) {
	this.init(options);
}

Canvas.prototype.init = function(options) {
   var options = options || {};
   // User must provide either tagName or both width and height.
   if (!(options.tagName || (options.width && options.height))) {
	throw 'Canvas requires options of either "tagName" or both "width" and "height".'
   }
   // User can't provide both canvas and width and height. Make up your mind!
   if (options.tagName && options.width && options.height) {
	throw 'Canvas requires options of either "tagName" or both "width" and "height". Cannot use both.'
   }
   this.tagName = options.tagName || null;
   this.width = options.width || null;
   this.height = options.height || null;
   this.snap = null;
   if (this.tagName)
	   this.snap = Snap(this.tagName);
   else
	   this.snap = Snap(this.width, this.height);
}


function Drawing( canvas, svgString, transformString, timeBetweenDraws ) {
    this.options = {};
    this.canvas = canvas;
    this.fragment = Snap.parse( svgString );
    this.pathArray = this.fragment.selectAll('path');
    this.group = this.canvas.snap.g().transform( transformString ).drag();
    this.timeBetweenDraws = timeBetweenDraws;
};

Drawing.prototype.init = function( svgString, transformString ) {
      this.group.clear();
      this.currentPathIndex = 0;
};

Drawing.prototype.endReached = function() {
	if( ( this.currentPathIndex >= this.pathArray.length ) || ( this.currentPathIndex < 0) ) {
        return true;
    };
};

Drawing.prototype.callOnFinished = function() {
}

Drawing.prototype.initDraw = function() {
    this.init();
    this.draw();
};

Drawing.prototype.reverseDraw = function() {
        this.init();
        var drawGroup = this.group;
        this.pathArray.forEach( function( el ) {
                drawGroup.append(el);           // draw it first, so we can slowly delete it, may want to add a check to see if it already exists then we may not need to
        } );
        this.currentPathIndex = this.pathArray.length - 1;
        this.options.reverse = true;
        this.draw();
}

Drawing.prototype.quickDraw = function() {
    this.init();
    this.timeBetweenDraws = 0;
    this.draw();
};

Drawing.prototype.draw = function() {         // this is the main animation bit
    if( this.endReached() ) {
        if( this.callOnFinished ) {
            this.callOnFinished();
            return
        };
    };
    var myPath = this.pathArray[ this.currentPathIndex ] ;

    this.leng = myPath.getTotalLength();
    this.group.append( myPath );
     myPath.attr({
       fill: 'none',
       "stroke-dasharray": this.leng + " " + this.leng,
       "stroke-dashoffset": this.leng
     });

    if( myPath.attr('stroke') == 'none' ) {
        myPath.attr({ stroke: '#000000' });
    }

    if( this.options.reverse ) {
        myPath.attr({ "stroke-dashoffset": 0 });
        this.currentPathIndex--;
        myPath.animate({"stroke-dashoffset": this.leng}, this.timeBetweenDraws, mina.easeout, this.draw.bind( this ) );
    } else {
        this.currentPathIndex++;
        myPath.animate({"stroke-dashoffset": 0}, this.timeBetweenDraws, mina.easeout, this.draw.bind( this ) );

    }
};

function loadPaths( filename, object, callback ) {
        Snap.load( filename, function( frag ) {
                object.fragment = frag;
                object.pathArray = frag.selectAll('path');
                callback();
        });

}

// var drawing = new Drawing(undefined,'t10,10',0);
// loadPaths( 'Dreaming_tux.svg', drawing, drawing.reverseDraw.bind( drawing ) );

/*
var myDrawing1 = new Drawing( svgString1, 't0, 0, s1.8', 800 );
var myDrawing2 = new Drawing( svgString2, 't69,50 s1.8', 3000 );
var myDrawing3 = new Drawing( svgString2, 't150,150 s1.8', 5000 );
var myDrawing4 = new Drawing( svgString1, 't50,50 s1.8', 5000 );


myDrawing1.callOnFinished = function() { myDrawing2.initDraw() };
myDrawing2.callOnFinished = function() { myDrawing3.initDraw() };
myDrawing3.callOnFinished = function() { myDrawing1.callOnFinished = function() {}; myDrawing1.reverseDraw() };
*/

var theCanvas = new Canvas({width: 500, height: 500});
var octogonPathStrings = [
                          '<path id="s3" d="M 60 0 L 120 0 L 180 60" stroke="red"/>',
                          '<path id="s3" d="M 180 60 L 180 120 L 120 180 L 60 180" stroke="purple"/>',
                          '<path id="s3" d="M 60 180 L 0 120 L 0 60 L 60 0" stroke="blue"/>'
			 ];

var octogonDrawings = [];
for (var i = 0; i < octogonPathStrings.length; i++) {
  // console.log(octogonPathStrings[i]);
  var currentDrawing = new Drawing(theCanvas, octogonPathStrings[i], 't0, 0, s1.8', 800 );
  octogonDrawings[i] = currentDrawing;
}

if (octogonDrawings.length > 0) {
  octogonDrawings[0].initDraw();
  for (var i = 0; i < octogonDrawings.length - 1; i++) {
    var currentDrawing = octogonDrawings[i];
    // This is how you pass the value of i into the generated function.
    // https://stackoverflow.com/questions/19696015/javascript-creating-functions-in-a-for-loop
    currentDrawing.callOnFinished = (function(val) {
		      return function(){ 
		        var nextDrawing = octogonDrawings[val+1];
		        nextDrawing.initDraw();
		      }
		    })(i);
  }
}

// Hard-coded version
var hardCodedOctogonDrawings = [];
hardCodedOctogonDrawings[0] = new Drawing( theCanvas, octogonPathStrings[0], 't60, 80, s1.8', 800 );
hardCodedOctogonDrawings[1] = new Drawing( theCanvas, octogonPathStrings[1], 't60, 80, s1.8', 800 );
hardCodedOctogonDrawings[2] = new Drawing( theCanvas, octogonPathStrings[2], 't60, 80, s1.8', 800 );
hardCodedOctogonDrawings[0].initDraw();
hardCodedOctogonDrawings[0].callOnFinished = function() { hardCodedOctogonDrawings[1].initDraw() };
hardCodedOctogonDrawings[1].callOnFinished = function() { hardCodedOctogonDrawings[2].initDraw() };


//myDrawing2.callOnFinished = function() { myDrawing2.callOnFinished = myDrawing3.initDraw(); myDrawing2.reverseDraw() };
//myDrawing3.callOnFinished = function() { myDrawing3.callOnFInished = function() {}; myDrawing3.reverseDraw() };

    </script>
  </body>
</html>
