<html>
  <head>
    <script src="js/snap.svg.js"></script>
  </head>
  <body>
    <div id="content">
      <!-- The stroke dash-array and stroke-dashoffset, and animate.from must be the same as the length of the line (here, it's 500).
	    I think I'll have to set the animate.dur depending on the length of the line
            being drawn: shorter for short lines and longer for long lines. -->
      <!-- Use http://snapsvg.io/start/ Less object-orienty, but backed by adobe -->
      <!-- Or http://svgjs.com/  This one seems more object-oriented, but not as much traction.           svg.js's polyline plot() seems to have nice animation features. -->
      <!--
      <svg id="svgout" width="500" height="500">
        <line x1="0" y1="0" x2="300" y2="400"
	  style="stroke:rgb(255,0,0);stroke-width:2;stroke-dasharray:500,500; stroke-dashoffset:500">
          <animate begin="0" attributeName="stroke-dashoffset"
              from="500" to="0" dur="2s" fill="freeze"/>
        </line>
</svg>
      -->

      <svg id="svgout" width="500" height="500">
      </svg>
    </div>
    <script>

// To understand the meaning of the paths below:
// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
/*
    var svgString1 = '<path id="s3" d="M 60 0 L 120 0 L 180 60 L 180 120 L 120 180 L 60 180 L 0 120 L 0 60 Z" stroke="blue"/>';
var svgString2 = '<path id="s3" d="M 60 0 L 120 0 L 180 60 L 180 120 L 120 180 L 60 180 L 0 120 L 0 60 Z" stroke="red"/>';
*/

function Drawing( svgString, transformString, timeBetweenDraws ) {
    this.svg = Snap("#svgout");
    this.fragment = Snap.parse( svgString );
    this.pathArray = this.fragment.selectAll('path');
    this.group = this.svg.g().transform( transformString ).drag();
    this.timeBetweenDraws = timeBetweenDraws;
};

Drawing.prototype.init = function( svgString, transformString ) {
      this.group.clear();
      this.currentPathIndex = 0;
};

Drawing.prototype.endReached = function() {
    if( this.currentPathIndex >= this.pathArray.length ) {
        return true;
    };
};

Drawing.prototype.callOnFinished = function() {
}

Drawing.prototype.initDraw = function() {
    this.init();
    this.draw();
};

Drawing.prototype.quickDraw = function() {
    this.init();
    this.timeBetweenDraws = 0;
    this.draw();
};

Drawing.prototype.draw = function() {         // this is the main animation bit
    if( this.endReached() ) {
        if( this.callOnFinished ) {
            this.callOnFinished();
            return
        };
    };
    var myPath = this.pathArray[ this.currentPathIndex ] ;

    this.leng = myPath.getTotalLength();
    console.log("leng: " + this.leng);
    console.log("currentPathIndex: " + this.currentPathIndex);
    console.log("myPath: " + myPath);
    console.log("pathArray: " + this.pathArray);

    this.group.append( myPath );

     myPath.attr({
       fill: 'none',
       "stroke-dasharray": this.leng + " " + this.leng,
       "stroke-dashoffset": this.leng
     });

     this.currentPathIndex++;

     myPath.animate({"stroke-dashoffset": 0}, this.timeBetweenDraws, mina.easeout, this.draw.bind( this ) );

};

var Path = function() {
  this.init();
}

Path.prototype.init = function() {
  this.x = 0;
  this.y = 0;
  this.direction = -90;
  this.pathDescription = "";
  this.directionRadians = function() { return this.toRad(this.direction); };
  this.penIsDown = true;
  this.color = null;
}


Path.prototype.turn = function(degrees) {
  this.direction += degrees;
  this.direction = this.direction % 360;
  return this;
}

Path.prototype.rad = Math.PI / 180.0;
	
Path.prototype.toRad = function(degrees) {
  return degrees * this.rad;
}

Path.prototype.go = function(distance) {
  var currentDirectionRadians = this.toRad(this.dir);

  this.x += Math.round(distance * Math.cos(this.directionRadians()));
  this.y += Math.round(distance * Math.sin(this.directionRadians()));

  if (this.penIsDown)
    this.pathDescription += "L ";
  else
    this.pathDescription += "M ";

  this.pathDescription += this.x + " " + this.y + " ";

  return this;
}

Path.prototype.penup = function() {
  this.penIsDown = false;
}

Path.prototype.pendown = function() {
  this.penIsDown = true;
}

Path.prototype.pathString = function() {
  var toReturn = '<path id="s3" d="M 0 0 ' + this.pathDescription + '"';
  if (this.color != null) {
    toReturn += ' stroke="' + this.color + '"';
  }
  toReturn += "/>";
  return toReturn;
}

Path.prototype.draw = function() {
  var myDrawing = new Drawing(this.pathString(), 't0, 0, s1.8', 800 );
  myDrawing.initDraw();
}

var thePath = new Path();
thePath.color = "blue";
thePath.turn(135);
thePath.go(200);
thePath.penup();
thePath.turn(-90);
thePath.go(50);
thePath.pendown();
thePath.turn(40);
thePath.go(20);
console.log(thePath.pathString());
thePath.draw();

/**
var myDrawing1 = new Drawing( svgString1, 't0, 0, s1.8', 800 );
var myDrawing2 = new Drawing( svgString2, 't69,50 s1.8', 3000 );
var myDrawing3 = new Drawing( svgString2, 't150,150 s1.8', 5000 );

myDrawing1.initDraw();
myDrawing1.callOnFinished = function() { myDrawing2.initDraw() };
myDrawing2.callOnFinished = function() { myDrawing3.initDraw() };
**/

    </script>
  </body>
</html>

